<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta name="description" content="Alexey S. Omelchenko's personal website"/>
    <meta name="author" content="Alexey S. Omelchenko"/>
    <meta name="google-site-verification" content="rSjyvgkL1axuyImfyf_G55kB4L2oX8R6l9MFcTeVBxA" />
    <title>Alexey S Omelchenko personal website</title>
    <link rel="stylesheet" href="stylesheets/default.css"/>
    <script type="text/javascript" src="http://code.jquery.com/jquery-1.4.2.min.js"></script>
    <script type="text/javascript" src="javascripts/behavior.js"></script>
	<link type="text/css" rel="stylesheet" href="stylesheets/prettify.css" />    
    <script type="text/javascript" src="javascripts/prettify/prettify.js"></script>
    <!--[if IE]>
	<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
</head>
<body onload="prettyPrint()">
    <header id="logo">
        <h1>Alexey Omelchenko's Pages</h1>
    </header>
    <nav id="main">
        <ul>
            <li><a class="selected" href="#">Home</a></li>
            <li><a href="about.html">About</a></li>
            <li><a href="resume.html">R&eacute;sum&eacute;</a></li>
            <li><a href="contact.html">Contact</a></li>
        </ul>
    </nav>
    <section id="intro">
    	<header>
    		<h2>Coding Notes</h2>
        </header>
    </section>
    <div id="main" class="clear">
        <section id="articles">
            <article class="blogPost">
                <header>
                    <h2>Minimalist GUI Server on CentOS 7</h2>
                    <p>Posted on <time pubdate datetime="2015-02-22T14:52:50-05:00">February 22nd 2015</time></p>
                </header>
				<p>Most VPS hosting providers have CentOS platform as template. I have
				 successfully run CentOS 6.5 on 512 MiB. CPU speed is not that important at this
				 point. Here I will setup CentOS 7 - there are some changes in comparison with
				 6.5 or earlier.</p>
				<p>Protect our server from SSH brute force attack. If we have installed iptables
				 services, we can do: <pre class="prettyprint">
# Clear everything from iptables
iptables -F

# Allow all packets for established connections
# (match packets by state where state = ESTABLISHED,RELATED)
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# Record IP address of all new attempts to connect to SSH(22) port
iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --set

# Match new attempts to connect to SSH port from IP address recorded in
# last 180 seconds 4 times or more, update record and drop that attempt
iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent \
 --update --seconds 180 --hitcount 4 -j DROP

# Allow new SSH connections that were not matched above
iptables -A INPUT -p tcp --dport 22 -m state --state NEW -j ACCEPT

# Allow all packets from loop-back interface - connections from localhost
iptables -A INPUT -i lo -j ACCEPT

# Allow PING requests
iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT

# Deny all other input and forward requests, allow all output
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT ACCEPT
</pre>
				 To save the policies we will need two packages and one command:
<pre class="prettyprint">
yum install iptables-services policycoreutils

# Save firewall settings
service iptables save
</pre>				 without policycoreutils I have had an error: "restorecon: command not found"</p>
				<p>Next I will "protect" the system from IPv6 attacks. Since I do not need any IPv6
				 services, I will just disable IPv6 network services. The right way to do it on
				 CentOS 7 is to open <code>/etc/sysctl.conf</code> and add the following lines:<pre>
net.ipv6.conf.all.disable_ipv6 = 1
net.ipv6.conf.default.disable_ipv6 = 1</pre><br/>
				 To apply changes and check the result: <pre>
systemctl restart network
ip addr show</pre></p>
				<p>Change name of the server if you want. On CentOS 7 the right way to do it: <pre>
hostnamectl set-hostname (--static|--transient|--pretty) <new name></pre></p>
				<p>Setup local time zone. By default the timezone of VPS usually set up to the
				 actual local timezone of the physical server. So if that is not what you want,
				 replace symbolic link to <code>/usr/share/zoneinfo/&lt;whatever you want></code>
				 at <code>/etc/localtime</code></p>
				<p>Next I setup windows manager. To make true minimalist server I will use the
				 simplest windows manager I know - <a href="http://dwm.suckless.org">dwm</a>.<br/>
				 I cannot install it though yum, so I have to install prerequisites manually.
				 One way to do it - install whole group for X Windows
				 <pre>yum group install "X Windows System"</pre> but it will install a lot of
				 unnecessary packages. So I prefer another trick. Install dmenu and xterm - I will
				 need them anyway - and they are available through yum though dmenu is in EPEL
				 repository. Enabling EPEL repository in CentOS 7 is simpler than ever:<pre>
yum install epel-release</pre> Then I can install <code>dmenu</code> and <code>xterm</code> with all
				 dependencies. Afrer that I have to install four remaining prerequisites for dwm:
				 <code>libX11-devel</code>, <code>libXinerama-devel</code> and of course
				 <code>gcc</code> and <code>make</code>. This installs only necessary packages from
				 the repositories. We have to compile dwm. It does not have any external settings,
				 so every customization is done through config.h file of its source code. So get
				 the source code, unzip it, make and install. <pre>
wget http://dl.suckless.org/dwm/dwm-6.0.tar.gz</pre></p>
				<p>Now that I have necessary GUI packages installed, I will set up VNC server. <pre>
yum install tigervnc-server</pre>I will need a user for VNC service.<pre>
useradd someuser
passwd someuser</pre>After that I will need to setup service for the user. Protocol VNC does not
				 provide a way to chose a user name when you connect. Instead you have to chose
				 service port and bind it to the user on the server settings. On CentOS 7 it is done
				 through service files. I have to copy sample service file to the directory and then
				 modify it.<pre>
cp /lib/systemd/system/vncserver@.service \
 /etc/systemd/system/vncserver@:1.service</pre>Here I chose
				 port 5901 (display #1). Then I modify its content:<pre>

[Unit]
Description=Remote desktop service (VNC)
After=syslog.target network.target

[Service]
Type=forking
# Clean any existing files in /tmp/.X11-unix environment
ExecStartPre=/bin/sh -c '/usr/bin/vncserver -kill %i > /dev/null 2>&1 || :'
ExecStart=/sbin/runuser -l <strong>someuser</strong> -c "/usr/bin/vncserver %i \
 -geometry 1200x650"
PIDFile=/home/<strong>someuser</strong>/.vnc/%H%i.pid
ExecStop=/bin/sh -c '/usr/bin/vncserver -kill %i > /dev/null 2>&1 || :'

[Install]
WantedBy=multi-user.target

				</pre>Here we also can change display resolution. Next I have to setup VNC windows
				 manager for VCN user.<pre>
systemctl daemon-reload
systemctl enable vncserver@:1
su someuser

# under someuser run server
vncserver

</pre>It will ask for new password. This password VNC server will ask for remote
				 connection. Now we will modify <code>~/.vnc/xstartup</code> file to setup dwm. Here
				 is an example of the file. <pre class="prettyprint">
#!/bin/sh
[ -x /etc/vnc/xstartup ] && exec /etc/vnc/xstartup
[ -r $HOME/.Xresources ] && xrdb $HOME/.Xresources
vncconfig -iconic &
xterm -geometry 80x24+10+10 -ls -title "$VNCDESKTOP Desktop" &
while true; do
	dwm >>$HOME/.vnc/.dwm.log 2>&1
done</pre>
				 last cycle is to prevent "dead" screen when you suddenly close your dwm process.
				 Here we can return to root session and restart VNC:<pre>
systemctl restart vncserver@:1</pre></p>
				<p>Now use your favorite VNC Viewer to connect.</p>
            </article>
            <article class="blogPost">
                <header>
                    <h2>unique_ptr vs auto_ptr</h2>
                    <p>Posted on <time pubdate datetime="2013-04-08T23:31:45+03:00">April 8th 2013</time></p>
                </header>
				<p>C++11 standard now has a set of new smart pointers classes.
				 unique_ptr is the one that makes auto_ptr deprecated. And there is a good
				 reason. So what are the differences between these two classes from a user
				 point or view?</p>
				<p>auto_ptr was designed to serve two scenarios: take ownership of
				 a dynamically allocated object and transfer the object by pointer
				 in function return so that instead of<br/>
				 <code>vector&lt;int>* createVector();</code> we can write<br/>
				 <code>auto_ptr&lt; vector&lt;int> > createVector();</code> and make sure that in
				 case of any exception all destructors will be called and the memory will be deallocated.</p>
				<p>Another thing worth to mention is what auto_ptr was NOT designed for. It was
				 not designed to store objects in a container or to make copies of itself. It was
				 not designed to be very useful for controlling life time of objects inside other
				 data types. But it is still possible to write code like this:</p>
                <?prettify lang=cpp?>
                <pre class="prettyprint">
struct MyClass {
    std::auto_ptr&lt;int> MyPtr;
    MyClass() : MyPtr(new int) {}
};</pre>
                <p>but it leads to effects that are hardly useful. auto_ptr does not forbid copy
				 construction or assignment, because C++ before C++11 did not have any facility to
				 forbid it and solve the designed scenarios at the same time.</p>
                <p>Now we have lvalue references and special new "move" semantics for operations
				 with those references. All this maked possible to create another smart pointer
				 that solves the initial scenarios but makes it hard to misuse it. <code>unique_ptr</code>
				 does not have copy constructor or copy assignment operator. You still can transfer
				 ownership of the pointer but it requires explicit statement:
				 <code>unique_ptr&lt;int> myNewIntPtr = std::move(myOldIntPtr);</code></p>
				<p>Two additional bonuses unique_ptr provides: ability to store pointer to an array
				 (with access to elements by index through []) and possibility to specify, how
				 the object has to be destroyed. The latter introduces one more scenario for the
				 new smart pointer.</p>
				<p>Consider some old-style C library with a function returning some old-style C string.
				 The string is returned as <code>char*</code> allocated with <code>malloc</code>.
				 auto_ptr&lt;char> is useless in this case - it only can destroy objects by calling standard
				 delete. The default version of unique_ptr&lt;char> uses the same approach, because
				 it uses default_delete&lt;char> as default the second template parameter. But we can
				 specify another class.</p>
				<p>unique_ptr is designed to have no overhead in size or runtime performance in comparison
				 whith classic pointer. It depends on the deleter, so I am going to write some
				 malloc_deleter without any overhead as well. And show its usage with the example
				 of gcc type names unmangling.</p>
                <pre class="prettyprint">
#include &lt;memory>
#include &lt;cstdlib>
#include &lt;cxxabi.h>
#include &lt;stdexcept>
#include &lt;iostream>

// The class does not have any member variables, therefore it does not
// make any overhead in size or performance.
template&lt;void (*fun)(void*)>
struct fun_delete
{
    void operator () (void* p) { return (*fun)(p); }
};

typedef fun_delete&lt;std::free> malloc_delete;

std::unique_ptr&lt;char, malloc_delete> demangle_type_name(const char* name)
{
    int status;
    // The buffer has to be allocated with malloc or null. If null, then
    // the result string is allocated with malloc.
    std::unique_ptr&lt;char, malloc_delete> real_name (
        abi::__cxa_demangle(name, 0, 0, &amp;status));

    if( 0 != status )
        throw std::runtime_error("Fail to demangle");

    return real_name;
}

int main(int argc, char** argv)
{
    std::cout &lt;&lt; demangle_type_name(typeid(1)).get() &lt;&lt; std::endl;
    std::cout &lt;&lt; demangle_type_name(typeid(2.0)).get() &lt;&lt; std::endl;
    std::cout &lt;&lt; demangle_type_name(typeid("42")).get() &lt;&lt; std::endl;
}
</pre>
            </article>
        </section>
        <aside>
            <section>
                <header>
                    <h3>Useful Links</h3>
                </header>
                <nav id="categories">
                    <ul>
                        <li><a href="http://www.cplusplus.com">CPlusPlus.com</a></li>
                        <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf">C++11 Standard</a></li>
                        <li><a href="http://cppcms.com">C++ Web Framework</a></li>
                        <li><a href="http://www.sugarcrm.com/community">SugarCRM Community</a></li>
                        <li><a href="http://www.nas4free.org">NAS4Free/ZFS v28</a></li>
                        <li><a href="http://www.netapp.com">NetApp</a></li>
                    </ul>
                </nav>
            </section>
        </aside>
    </div>
    <footer>
    	<div class="clear">
            <section id="about">
                <header>
                    <h3>About</h3>
                </header>
                <p>This is my personal web site. Here I experiment with HTML5 and CSS, so it is under construction. Taking into account my native language is C++, not HTML, the site might remain under construction for quite a while</p>
            </section>
            <section>
                <header>
                    <h3>News</h3>
                </header>
                <nav id="blogRoll">
                    <ul>
                        <li><a href="#">Under Construction</a></li>
                    </ul>
                </nav>
            </section>
            <section>
                <header>
                    <h3>Site Map</h3>
                </header>
                <nav id="siteMap">
                    <ul>
                        <li><a href="#">Home</a></li>
                        <li><a href="about.html">About</a></li>
                        <li><a href="resume.html">R&eacute;sum&eacute;</a></li>
                        <li><a href="contact.html">Contact</a></li>
                    </ul>
                </nav>
            </section>
        </div>
    </footer>
</body>
</html>
